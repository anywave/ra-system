"""
Test Harness for Prompt 55: Ra.Chamber.TeslaVortex

Tests scalar-torsion reactor model based on:
- Tesla turbine vortex dynamics
- Keely harmonic overlays
- Torsion field modulation

Simulates layered scalar shells with configurable spin bias,
torsion envelope, and Keely-mode sympathetic resonance.
"""

import pytest
import math
from dataclasses import dataclass
from typing import Optional, List, Tuple
from enum import Enum, auto

# =============================================================================
# Constants
# =============================================================================

PHI = 1.618033988749895

# Keely mode ratios: symbolic integer -> frequency ratio
KEELY_RATIOS = {
    3: 1/3,   # Thirds
    6: 1/6,   # Sixths
    9: 1/9,   # Ninths
}

# Default base frequencies
BASE_FREQUENCY = 432.0  # Hz (harmonic base)
BASE_SPIN = 1.0  # Radians per tick


# =============================================================================
# Data Structures
# =============================================================================

@dataclass(frozen=True)
class VortexProfile:
    """Vortex field profile - radial spin and torsion envelope."""
    base_spin: float  # Baseline angular velocity (rad/tick)
    torsion_bias: float  # Field chirality (-1.0 to +1.0)
    layer_count: int  # Harmonic shell count
    keely_mode: Optional[int]  # Optional sympathetic octave mode (3, 6, or 9)

    def __post_init__(self):
        if not -1.0 <= self.torsion_bias <= 1.0:
            raise ValueError("torsion_bias must be in range [-1.0, 1.0]")
        if self.layer_count < 1:
            raise ValueError("layer_count must be >= 1")
        if self.keely_mode is not None and self.keely_mode not in KEELY_RATIOS:
            raise ValueError(f"keely_mode must be one of {list(KEELY_RATIOS.keys())}")


@dataclass(frozen=True)
class RaCoordinate:
    """Position in Ra spherical coordinate space."""
    theta: float  # 0 to π
    phi: float  # 0 to 2π
    h: float  # Height/shell (0-1)


@dataclass
class ScalarFieldComponent:
    """Component of scalar field generated by vortex."""
    amplitude: float  # Field strength (0-1)
    phase: float  # Phase angle (0 to 2π)
    frequency: float  # Oscillation frequency (Hz)
    spin_direction: int  # +1 = clockwise, -1 = counter-clockwise
    layer_index: int  # Which shell layer


@dataclass
class EmergenceCondition:
    """Conditions for emergence binding."""
    min_coherence: float  # Minimum coherence required
    harmonic_lock: bool  # Whether harmonic lock is achieved
    torsion_aligned: bool  # Whether torsion is field-aligned
    resonance_depth: int  # Number of resonant layers


@dataclass
class VortexState:
    """Runtime state of vortex chamber."""
    profile: VortexProfile
    current_phase: float  # Current rotation phase
    coherence_level: float  # Current coherence (0-1)
    active_layers: List[int]  # Indices of active layers
    field_components: List[ScalarFieldComponent]


# =============================================================================
# Core Functions
# =============================================================================

def get_keely_ratio(mode: Optional[int]) -> float:
    """Get Keely frequency ratio for mode."""
    if mode is None:
        return 1.0
    return KEELY_RATIOS.get(mode, 1.0)


def compute_layer_frequency(
    base_freq: float,
    layer_index: int,
    keely_mode: Optional[int]
) -> float:
    """
    Compute frequency for a specific layer.

    Uses φ-scaling between layers and Keely ratio modulation.
    """
    # φ-scale the frequency per layer
    phi_factor = PHI ** layer_index

    # Apply Keely ratio if mode is set
    keely_ratio = get_keely_ratio(keely_mode)

    return base_freq * phi_factor * keely_ratio


def compute_layer_amplitude(
    layer_index: int,
    layer_count: int,
    torsion_bias: float
) -> float:
    """
    Compute amplitude for a layer based on position and torsion.

    Inner layers have higher amplitude, modulated by torsion.
    """
    # Base amplitude decreases with layer (inner = stronger)
    base_amp = 1.0 - (layer_index / layer_count) * 0.5

    # Torsion modulates amplitude based on layer parity
    # Positive torsion boosts even layers, negative boosts odd
    parity = 1 if layer_index % 2 == 0 else -1
    torsion_mod = 1.0 + (torsion_bias * parity * 0.2)

    return max(0.0, min(1.0, base_amp * torsion_mod))


def compute_layer_phase(
    layer_index: int,
    base_spin: float,
    torsion_bias: float,
    time_tick: int
) -> float:
    """
    Compute phase for a layer at given time.

    Layers rotate at different speeds based on index and torsion.
    """
    # Layer spin rate scales with φ
    layer_spin = base_spin * (PHI ** (layer_index * 0.5))

    # Torsion affects spin direction
    direction = 1 if torsion_bias >= 0 else -1
    if layer_index % 2 == 1:
        direction *= -1  # Alternate layers counter-rotate

    phase = (layer_spin * time_tick * direction) % (2 * math.pi)
    return phase


def generate_vortex_field(
    profile: VortexProfile,
    time_tick: int = 0
) -> List[ScalarFieldComponent]:
    """
    Generate scalar field components from vortex profile.

    Creates one component per layer with appropriate frequency,
    amplitude, phase, and spin direction.
    """
    components = []

    for layer in range(profile.layer_count):
        freq = compute_layer_frequency(
            BASE_FREQUENCY,
            layer,
            profile.keely_mode
        )

        amplitude = compute_layer_amplitude(
            layer,
            profile.layer_count,
            profile.torsion_bias
        )

        phase = compute_layer_phase(
            layer,
            profile.base_spin,
            profile.torsion_bias,
            time_tick
        )

        # Spin direction based on torsion and layer
        spin = 1 if profile.torsion_bias >= 0 else -1
        if layer % 2 == 1:
            spin *= -1

        components.append(ScalarFieldComponent(
            amplitude=amplitude,
            phase=phase,
            frequency=freq,
            spin_direction=spin,
            layer_index=layer
        ))

    return components


def tesla_phase_map(profile: VortexProfile) -> List[Tuple[float, float]]:
    """
    Generate Tesla-style phase resonance map.

    Returns list of (phase_delta, amplitude_mod) tuples per layer.
    """
    phase_map = []

    for layer in range(profile.layer_count):
        # Phase delta based on layer position
        phase_delta = (2 * math.pi * layer) / profile.layer_count

        # Apply torsion rotation
        phase_delta += profile.torsion_bias * math.pi / 4

        # Normalize to [0, 2π)
        phase_delta = phase_delta % (2 * math.pi)

        # Amplitude modulation from Keely harmonics
        keely_ratio = get_keely_ratio(profile.keely_mode)
        amp_mod = 0.5 + 0.5 * math.cos(layer * keely_ratio * math.pi)

        phase_map.append((phase_delta, amp_mod))

    return phase_map


def compute_coherence_at_coordinate(
    components: List[ScalarFieldComponent],
    coord: RaCoordinate
) -> float:
    """
    Compute field coherence at a specific coordinate.

    Coherence is based on phase alignment of overlapping components.
    """
    if not components:
        return 0.0

    # Weight components by their reach to this coordinate
    total_weight = 0.0
    phase_sum_x = 0.0
    phase_sum_y = 0.0

    for comp in components:
        # Distance from layer to coordinate height
        layer_height = comp.layer_index / len(components)
        dist = abs(coord.h - layer_height)

        # Weight decreases with distance
        weight = comp.amplitude * math.exp(-dist * 3)

        # Accumulate phase as unit vector
        phase_sum_x += weight * math.cos(comp.phase)
        phase_sum_y += weight * math.sin(comp.phase)
        total_weight += weight

    if total_weight < 0.001:
        return 0.0

    # Coherence = magnitude of average phase vector
    avg_x = phase_sum_x / total_weight
    avg_y = phase_sum_y / total_weight
    coherence = math.sqrt(avg_x**2 + avg_y**2)

    return min(1.0, coherence)


def bind_vortex_chamber(
    profile: VortexProfile,
    coord: RaCoordinate,
    components: List[ScalarFieldComponent]
) -> EmergenceCondition:
    """
    Bind vortex chamber to coordinate with emergence conditions.

    Determines if conditions are met for emergence at this location.
    """
    coherence = compute_coherence_at_coordinate(components, coord)

    # Harmonic lock requires coherence > 0.72 (φ - 0.9)
    harmonic_lock = coherence > 0.72

    # Torsion alignment based on coordinate phi and torsion bias
    torsion_phase = coord.phi / (2 * math.pi)
    torsion_aligned = abs(torsion_phase - (0.5 + 0.5 * profile.torsion_bias)) < 0.2

    # Count resonant layers (amplitude > 0.5)
    resonance_depth = sum(1 for c in components if c.amplitude > 0.5)

    return EmergenceCondition(
        min_coherence=coherence,
        harmonic_lock=harmonic_lock,
        torsion_aligned=torsion_aligned,
        resonance_depth=resonance_depth
    )


def compute_total_field_energy(components: List[ScalarFieldComponent]) -> float:
    """Compute total field energy from all components."""
    return sum(c.amplitude**2 * c.frequency / BASE_FREQUENCY for c in components)


def compute_torsion_moment(components: List[ScalarFieldComponent]) -> float:
    """Compute net torsion moment from spin contributions."""
    moment = 0.0
    for comp in components:
        # Moment = amplitude * spin * layer_weight
        layer_weight = 1.0 / (comp.layer_index + 1)
        moment += comp.amplitude * comp.spin_direction * layer_weight
    return moment


# =============================================================================
# Test Cases
# =============================================================================

class TestVortexProfile:
    """Tests for VortexProfile data structure."""

    def test_valid_profile_creation(self):
        """Test creating a valid profile."""
        profile = VortexProfile(
            base_spin=1.0,
            torsion_bias=0.5,
            layer_count=5,
            keely_mode=3
        )
        assert profile.base_spin == 1.0
        assert profile.torsion_bias == 0.5
        assert profile.layer_count == 5
        assert profile.keely_mode == 3

    def test_profile_without_keely(self):
        """Test profile without Keely mode."""
        profile = VortexProfile(
            base_spin=0.5,
            torsion_bias=-0.3,
            layer_count=3,
            keely_mode=None
        )
        assert profile.keely_mode is None

    def test_torsion_bias_bounds(self):
        """Test torsion bias must be in [-1, 1]."""
        with pytest.raises(ValueError):
            VortexProfile(base_spin=1.0, torsion_bias=1.5, layer_count=3, keely_mode=None)

        with pytest.raises(ValueError):
            VortexProfile(base_spin=1.0, torsion_bias=-1.5, layer_count=3, keely_mode=None)

    def test_layer_count_positive(self):
        """Test layer count must be positive."""
        with pytest.raises(ValueError):
            VortexProfile(base_spin=1.0, torsion_bias=0.0, layer_count=0, keely_mode=None)

    def test_invalid_keely_mode(self):
        """Test invalid Keely mode raises error."""
        with pytest.raises(ValueError):
            VortexProfile(base_spin=1.0, torsion_bias=0.0, layer_count=3, keely_mode=5)


class TestKeelyRatios:
    """Tests for Keely mode frequency ratios."""

    def test_keely_mode_3(self):
        """Test thirds ratio."""
        assert get_keely_ratio(3) == pytest.approx(1/3)

    def test_keely_mode_6(self):
        """Test sixths ratio."""
        assert get_keely_ratio(6) == pytest.approx(1/6)

    def test_keely_mode_9(self):
        """Test ninths ratio."""
        assert get_keely_ratio(9) == pytest.approx(1/9)

    def test_keely_mode_none(self):
        """Test no Keely mode returns 1.0."""
        assert get_keely_ratio(None) == 1.0


class TestLayerFrequency:
    """Tests for layer frequency computation."""

    def test_base_layer_frequency(self):
        """First layer should use base frequency * keely ratio."""
        freq = compute_layer_frequency(432.0, 0, None)
        assert freq == pytest.approx(432.0)

    def test_phi_scaling(self):
        """Higher layers should scale by φ."""
        freq0 = compute_layer_frequency(432.0, 0, None)
        freq1 = compute_layer_frequency(432.0, 1, None)
        assert freq1 == pytest.approx(freq0 * PHI)

    def test_keely_mode_affects_frequency(self):
        """Keely mode should scale frequency."""
        freq_no_keely = compute_layer_frequency(432.0, 0, None)
        freq_keely_3 = compute_layer_frequency(432.0, 0, 3)
        assert freq_keely_3 == pytest.approx(freq_no_keely / 3)


class TestLayerAmplitude:
    """Tests for layer amplitude computation."""

    def test_inner_layer_higher_amplitude(self):
        """Inner layers should have higher amplitude."""
        amp0 = compute_layer_amplitude(0, 5, 0.0)
        amp4 = compute_layer_amplitude(4, 5, 0.0)
        assert amp0 > amp4

    def test_torsion_modulates_amplitude(self):
        """Positive torsion should boost even layers."""
        amp_even_pos = compute_layer_amplitude(0, 5, 0.5)
        amp_even_neg = compute_layer_amplitude(0, 5, -0.5)
        assert amp_even_pos > amp_even_neg

    def test_torsion_affects_odd_layers_opposite(self):
        """Negative torsion should boost odd layers."""
        amp_odd_pos = compute_layer_amplitude(1, 5, 0.5)
        amp_odd_neg = compute_layer_amplitude(1, 5, -0.5)
        assert amp_odd_neg > amp_odd_pos

    def test_amplitude_bounded(self):
        """Amplitude should be in [0, 1]."""
        for torsion in [-1.0, -0.5, 0.0, 0.5, 1.0]:
            for layer in range(10):
                amp = compute_layer_amplitude(layer, 10, torsion)
                assert 0.0 <= amp <= 1.0


class TestLayerPhase:
    """Tests for layer phase computation."""

    def test_phase_changes_with_time(self):
        """Phase should change over time."""
        phase0 = compute_layer_phase(0, 1.0, 0.5, 0)
        phase1 = compute_layer_phase(0, 1.0, 0.5, 10)
        assert phase0 != phase1

    def test_alternating_rotation(self):
        """Adjacent layers should rotate in opposite directions."""
        # With positive torsion, even layers rotate one way
        phase_even = compute_layer_phase(0, 1.0, 0.5, 10)
        phase_odd = compute_layer_phase(1, 1.0, 0.5, 10)
        # They should have different phases due to opposite rotation
        assert phase_even != phase_odd

    def test_phase_bounded(self):
        """Phase should be in [0, 2π)."""
        for tick in [0, 10, 100, 1000]:
            phase = compute_layer_phase(0, 1.0, 0.5, tick)
            assert 0.0 <= phase < 2 * math.pi


class TestGenerateVortexField:
    """Tests for vortex field generation."""

    def test_generates_correct_layer_count(self):
        """Should generate one component per layer."""
        profile = VortexProfile(
            base_spin=1.0,
            torsion_bias=0.0,
            layer_count=5,
            keely_mode=None
        )
        components = generate_vortex_field(profile)
        assert len(components) == 5

    def test_layer_indices_sequential(self):
        """Layer indices should be sequential."""
        profile = VortexProfile(
            base_spin=1.0,
            torsion_bias=0.0,
            layer_count=3,
            keely_mode=None
        )
        components = generate_vortex_field(profile)
        indices = [c.layer_index for c in components]
        assert indices == [0, 1, 2]

    def test_frequencies_increase_with_layer(self):
        """Frequencies should increase with layer (φ scaling)."""
        profile = VortexProfile(
            base_spin=1.0,
            torsion_bias=0.0,
            layer_count=4,
            keely_mode=None
        )
        components = generate_vortex_field(profile)
        for i in range(len(components) - 1):
            assert components[i+1].frequency > components[i].frequency

    def test_keely_mode_reduces_frequencies(self):
        """Keely mode should reduce all frequencies."""
        profile_no_keely = VortexProfile(
            base_spin=1.0, torsion_bias=0.0, layer_count=3, keely_mode=None
        )
        profile_keely = VortexProfile(
            base_spin=1.0, torsion_bias=0.0, layer_count=3, keely_mode=3
        )

        comp_no_keely = generate_vortex_field(profile_no_keely)
        comp_keely = generate_vortex_field(profile_keely)

        for i in range(3):
            assert comp_keely[i].frequency < comp_no_keely[i].frequency


class TestTeslaPhaseMap:
    """Tests for Tesla phase map generation."""

    def test_map_length_matches_layers(self):
        """Map should have entry per layer."""
        profile = VortexProfile(
            base_spin=1.0, torsion_bias=0.0, layer_count=5, keely_mode=None
        )
        phase_map = tesla_phase_map(profile)
        assert len(phase_map) == 5

    def test_phase_deltas_distributed(self):
        """Phase deltas should be distributed around circle."""
        profile = VortexProfile(
            base_spin=1.0, torsion_bias=0.0, layer_count=4, keely_mode=None
        )
        phase_map = tesla_phase_map(profile)
        phases = [p[0] for p in phase_map]

        # All phases should be in [0, 2π)
        for phase in phases:
            assert 0.0 <= phase < 2 * math.pi

    def test_amplitude_mods_bounded(self):
        """Amplitude modulations should be positive."""
        profile = VortexProfile(
            base_spin=1.0, torsion_bias=0.5, layer_count=6, keely_mode=3
        )
        phase_map = tesla_phase_map(profile)

        for _, amp_mod in phase_map:
            assert 0.0 <= amp_mod <= 1.0


class TestCoherenceComputation:
    """Tests for coherence at coordinate."""

    def test_empty_components_zero_coherence(self):
        """No components should give zero coherence."""
        coord = RaCoordinate(theta=math.pi/2, phi=math.pi, h=0.5)
        assert compute_coherence_at_coordinate([], coord) == 0.0

    def test_aligned_phases_high_coherence(self):
        """Components with aligned phases should give high coherence."""
        components = [
            ScalarFieldComponent(amplitude=0.8, phase=0.0, frequency=432, spin_direction=1, layer_index=0),
            ScalarFieldComponent(amplitude=0.8, phase=0.0, frequency=432, spin_direction=1, layer_index=1),
            ScalarFieldComponent(amplitude=0.8, phase=0.0, frequency=432, spin_direction=1, layer_index=2),
        ]
        coord = RaCoordinate(theta=math.pi/2, phi=math.pi, h=0.5)
        coherence = compute_coherence_at_coordinate(components, coord)
        assert coherence > 0.7

    def test_opposing_phases_lower_coherence(self):
        """Components with opposing phases should give lower coherence."""
        components = [
            ScalarFieldComponent(amplitude=0.8, phase=0.0, frequency=432, spin_direction=1, layer_index=0),
            ScalarFieldComponent(amplitude=0.8, phase=math.pi, frequency=432, spin_direction=-1, layer_index=1),
        ]
        # Use h=0.25 so both layers have equal weight (equidistant from both)
        coord = RaCoordinate(theta=math.pi/2, phi=math.pi, h=0.25)
        coherence = compute_coherence_at_coordinate(components, coord)
        assert coherence < 0.3


class TestBindVortexChamber:
    """Tests for vortex chamber binding."""

    def test_high_coherence_harmonic_lock(self):
        """High coherence should achieve harmonic lock."""
        profile = VortexProfile(
            base_spin=1.0, torsion_bias=0.0, layer_count=3, keely_mode=None
        )
        # Create aligned components
        components = [
            ScalarFieldComponent(amplitude=0.9, phase=0.0, frequency=432, spin_direction=1, layer_index=i)
            for i in range(3)
        ]
        coord = RaCoordinate(theta=math.pi/2, phi=math.pi, h=0.5)

        condition = bind_vortex_chamber(profile, coord, components)
        assert condition.harmonic_lock is True

    def test_low_coherence_no_harmonic_lock(self):
        """Low coherence should not achieve harmonic lock."""
        profile = VortexProfile(
            base_spin=1.0, torsion_bias=0.0, layer_count=3, keely_mode=None
        )
        # Create opposing components
        components = [
            ScalarFieldComponent(amplitude=0.5, phase=i * math.pi, frequency=432, spin_direction=1, layer_index=i)
            for i in range(3)
        ]
        coord = RaCoordinate(theta=math.pi/2, phi=math.pi, h=0.5)

        condition = bind_vortex_chamber(profile, coord, components)
        assert condition.harmonic_lock is False

    def test_resonance_depth_counts_strong_layers(self):
        """Resonance depth should count layers with amplitude > 0.5."""
        profile = VortexProfile(
            base_spin=1.0, torsion_bias=0.0, layer_count=4, keely_mode=None
        )
        components = [
            ScalarFieldComponent(amplitude=0.8, phase=0.0, frequency=432, spin_direction=1, layer_index=0),
            ScalarFieldComponent(amplitude=0.6, phase=0.0, frequency=432, spin_direction=1, layer_index=1),
            ScalarFieldComponent(amplitude=0.3, phase=0.0, frequency=432, spin_direction=1, layer_index=2),
            ScalarFieldComponent(amplitude=0.2, phase=0.0, frequency=432, spin_direction=1, layer_index=3),
        ]
        coord = RaCoordinate(theta=math.pi/2, phi=math.pi, h=0.5)

        condition = bind_vortex_chamber(profile, coord, components)
        assert condition.resonance_depth == 2  # Only layers 0 and 1 > 0.5


class TestFieldEnergy:
    """Tests for field energy computation."""

    def test_energy_increases_with_amplitude(self):
        """Higher amplitude should give higher energy."""
        comp_low = [ScalarFieldComponent(amplitude=0.3, phase=0.0, frequency=432, spin_direction=1, layer_index=0)]
        comp_high = [ScalarFieldComponent(amplitude=0.9, phase=0.0, frequency=432, spin_direction=1, layer_index=0)]

        energy_low = compute_total_field_energy(comp_low)
        energy_high = compute_total_field_energy(comp_high)

        assert energy_high > energy_low

    def test_energy_scales_with_frequency(self):
        """Higher frequency should contribute more energy."""
        comp_low_freq = [ScalarFieldComponent(amplitude=0.5, phase=0.0, frequency=216, spin_direction=1, layer_index=0)]
        comp_high_freq = [ScalarFieldComponent(amplitude=0.5, phase=0.0, frequency=864, spin_direction=1, layer_index=0)]

        energy_low = compute_total_field_energy(comp_low_freq)
        energy_high = compute_total_field_energy(comp_high_freq)

        assert energy_high > energy_low


class TestTorsionMoment:
    """Tests for torsion moment computation."""

    def test_positive_torsion_positive_moment(self):
        """Components with positive spin should give positive moment."""
        components = [
            ScalarFieldComponent(amplitude=0.8, phase=0.0, frequency=432, spin_direction=1, layer_index=0),
        ]
        moment = compute_torsion_moment(components)
        assert moment > 0

    def test_negative_torsion_negative_moment(self):
        """Components with negative spin should give negative moment."""
        components = [
            ScalarFieldComponent(amplitude=0.8, phase=0.0, frequency=432, spin_direction=-1, layer_index=0),
        ]
        moment = compute_torsion_moment(components)
        assert moment < 0

    def test_balanced_spins_near_zero_moment(self):
        """Equal opposing spins should nearly cancel."""
        components = [
            ScalarFieldComponent(amplitude=0.5, phase=0.0, frequency=432, spin_direction=1, layer_index=0),
            ScalarFieldComponent(amplitude=0.5, phase=0.0, frequency=432, spin_direction=-1, layer_index=0),
        ]
        moment = compute_torsion_moment(components)
        assert abs(moment) < 0.1


class TestIntegrationScenarios:
    """End-to-end integration tests."""

    def test_full_vortex_generation_cycle(self):
        """Test complete vortex field generation and binding."""
        profile = VortexProfile(
            base_spin=1.0,
            torsion_bias=0.3,
            layer_count=5,
            keely_mode=3
        )

        # Generate field
        components = generate_vortex_field(profile, time_tick=100)
        assert len(components) == 5

        # Generate phase map
        phase_map = tesla_phase_map(profile)
        assert len(phase_map) == 5

        # Bind to coordinate
        coord = RaCoordinate(theta=math.pi/2, phi=math.pi, h=0.5)
        condition = bind_vortex_chamber(profile, coord, components)

        assert condition.min_coherence >= 0.0
        assert condition.resonance_depth >= 0

    def test_time_evolution(self):
        """Test field evolution over time."""
        profile = VortexProfile(
            base_spin=1.0,
            torsion_bias=0.5,
            layer_count=4,
            keely_mode=None
        )

        phases_t0 = [c.phase for c in generate_vortex_field(profile, time_tick=0)]
        phases_t10 = [c.phase for c in generate_vortex_field(profile, time_tick=10)]
        phases_t100 = [c.phase for c in generate_vortex_field(profile, time_tick=100)]

        # Phases should change over time
        assert phases_t0 != phases_t10
        assert phases_t10 != phases_t100

    def test_keely_mode_comparison(self):
        """Compare field characteristics across Keely modes."""
        base_profile = VortexProfile(
            base_spin=1.0, torsion_bias=0.0, layer_count=3, keely_mode=None
        )
        keely3_profile = VortexProfile(
            base_spin=1.0, torsion_bias=0.0, layer_count=3, keely_mode=3
        )
        keely9_profile = VortexProfile(
            base_spin=1.0, torsion_bias=0.0, layer_count=3, keely_mode=9
        )

        base_energy = compute_total_field_energy(generate_vortex_field(base_profile))
        keely3_energy = compute_total_field_energy(generate_vortex_field(keely3_profile))
        keely9_energy = compute_total_field_energy(generate_vortex_field(keely9_profile))

        # Higher Keely mode (lower ratio) should have lower energy
        assert keely9_energy < keely3_energy < base_energy


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
